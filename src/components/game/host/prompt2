optimalisasikan halaman halaman ini 

src/app/game/[roomCode]/host
"use client";
import { useEffect, useState, useCallback } from "react";
import { useParams } from "next/navigation";
import { supabase } from "@/lib/supabase";
import { motion, AnimatePresence } from "framer-motion";
import PlayersPanel from "@/components/game/host/PlayersPanel";
import GameBackground from "@/components/game/host/GameBackground";
import ZombieCharacter from "@/components/game/host/ZombieCharacter";
import RunningCharacters from "@/components/game/host/RunningCharacters";
import GameUI from "@/components/game/host/GameUI";
import BackgroundEffects from "@/components/game/host/BackgroundEffects";

interface Player {
  id: string;
  nickname: string;
  character_type: string;
  score: number;
  is_alive: boolean;
  joined_at: string;
}

interface GameRoom {
  id: string;
  room_code: string;
  title: string;
  status: string;
  max_players: number;
  current_phase: string;
}

interface PlayerHealthState {
  id: string;
  player_id: string;
  room_id: string;
  health: number;
  max_health: number;
  speed: number;
  is_being_attacked: boolean;
  last_attack_time: string;
}

interface PlayerState {
  id: string;
  health: number;
  speed: number;
  isBeingAttacked: boolean;
  position: number;
  lastAttackTime: number;
  attackIntensity: number;
  countdown?: number; // Tambahkan countdown untuk setiap pemain
}

interface ZombieState {
  isAttacking: boolean;
  targetPlayerId: string | null;
  attackProgress: number;
  basePosition: number;
  currentPosition: number;
}

interface GameCompletion {
  id: string;
  player_id: string;
  room_id: string;
  final_health: number;
  correct_answers: number;
  total_questions_answered: number;
  is_eliminated: boolean;
  completion_type: string;
  completed_at: string;
}

const characterGifs = [
  {
    src: "/images/character.gif",
    fallback: "/character/character.gif",
    rootFallback: "/character.gif",
    alt: "Green Character",
    color: "bg-green-500",
    type: "robot1",
  },
  {
    src: "/images/character1.gif",
    fallback: "/character/character1.gif",
    rootFallback: "/character1.gif",
    alt: "Blue Character",
    color: "bg-blue-500",
    type: "robot2",
  },
  {
    src: "/images/character2.gif",
    fallback: "/character/character2.gif",
    rootFallback: "/character2.gif",
    alt: "Red Character",
    color: "bg-red-500",
    type: "robot3",
  },
  {
    src: "/images/character3.gif",
    fallback: "/character/character3.gif",
    rootFallback: "/character3.gif",
    alt: "Purple Character",
    color: "bg-purple-500",
    type: "robot4",
  },
  {
    src: "/images/character4.gif",
    fallback: "/character/character4.gif",
    rootFallback: "/character4.gif",
    alt: "Orange Character",
    color: "bg-orange-500",
    type: "robot5",
  },
];

export default function HostGamePage() {
  const params = useParams();
  const roomCode = params.roomCode as string;

  // Game animation states
  const [animationTime, setAnimationTime] = useState(0);
  const [gameMode, setGameMode] = useState<"normal" | "panic">("normal");
  const [isClient, setIsClient] = useState(false);
  const [screenWidth, setScreenWidth] = useState(1200);
  const [imageLoadStatus, setImageLoadStatus] = useState<{ [key: string]: boolean }>({});

  // Game data states
  const [players, setPlayers] = useState<Player[]>([]);
  const [gameRoom, setGameRoom] = useState<GameRoom | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [completedPlayers, setCompletedPlayers] = useState<Player[]>([]);
  const [showCompletionPopup, setShowCompletionPopup] = useState(false);

  // Enhanced player states with real-time health and speed sync from database
  const [playerStates, setPlayerStates] = useState<{ [playerId: string]: PlayerState }>({});
  const [playerHealthStates, setPlayerHealthStates] = useState<{ [playerId: string]: PlayerHealthState }>({});

  // Zombie attack system
  const [zombieState, setZombieState] = useState<ZombieState>({
    isAttacking: false,
    targetPlayerId: null,
    attackProgress: 0,
    basePosition: 500,
    currentPosition: 500,
  });

  // Visual effects
  const [recentAttacks, setRecentAttacks] = useState<Set<string>>(new Set());
  const [backgroundFlash, setBackgroundFlash] = useState(false);

  // Get character data by type
  const getCharacterByType = (type: string) => {
    return characterGifs.find((char) => char.type === type) || characterGifs[0];
  };

  // Initialize player states with real health and speed from database
  const initializePlayerStates = useCallback((playersData: Player[], healthData: PlayerHealthState[]) => {
    const newStates: { [playerId: string]: PlayerState } = {};
    const newHealthStates: { [playerId: string]: PlayerHealthState } = {};

    playersData.forEach((player, index) => {
      const healthState = healthData.find((h) => h.player_id === player.id);
      const currentHealth = healthState?.health ?? 3;
      const currentSpeed = healthState?.speed ?? 20;

      newStates[player.id] = {
        id: player.id,
        health: currentHealth,
        speed: currentSpeed,
        isBeingAttacked: healthState?.is_being_attacked ?? false,
        position: index,
        lastAttackTime: healthState ? new Date(healthState.last_attack_time).getTime() : 0,
        attackIntensity: 0,
        countdown: undefined, // Initialize countdown as undefined
      };

      if (healthState) {
        newHealthStates[player.id] = healthState;
      }
    });

    setPlayerStates(newStates);
    setPlayerHealthStates(newHealthStates);
  }, []);

  // Enhanced zombie attack animation
  const handleZombieAttack = useCallback((playerId: string, newHealth: number, newSpeed: number) => {
    console.log(`üßü Zombie menyerang pemain ${playerId}! Kesehatan: ${newHealth}, Kecepatan: ${newSpeed}`);
    setZombieState({
      isAttacking: true,
      targetPlayerId: playerId,
      attackProgress: 0,
      basePosition: 500,
      currentPosition: 500,
    });

    setPlayerStates((prev) => ({
      ...prev,
      [playerId]: {
        ...prev[playerId],
        health: newHealth,
        speed: newSpeed,
        isBeingAttacked: true,
        lastAttackTime: Date.now(),
        attackIntensity: 0.5,
        countdown: undefined, // Reset countdown after attack
      },
    }));

    setRecentAttacks((prev) => new Set([...prev, playerId]));
    setBackgroundFlash(true);
    setGameMode("panic");

    let progress = 0;
    const attackInterval = setInterval(() => {
      progress += 0.05;
      setZombieState((prev) => ({
        ...prev,
        attackProgress: progress,
        currentPosition: prev.basePosition * (1 - progress * 0.8),
      }));

      if (progress >= 0.5 && progress < 0.55) {
        setBackgroundFlash(true);
        console.log("üí• Zombie mengenai!");
      }

      if (progress >= 1) {
        clearInterval(attackInterval);
        setZombieState({
          isAttacking: false,
          targetPlayerId: null,
          attackProgress: 0,
          basePosition: 500,
          currentPosition: 500,
        });

        setPlayerStates((prev) => ({
          ...prev,
          [playerId]: {
            ...prev[playerId],
            isBeingAttacked: false,
            attackIntensity: 0,
          },
        }));

        setRecentAttacks((prev) => {
          const newSet = new Set(prev);
          newSet.delete(playerId);
          return newSet;
        });

        setBackgroundFlash(false);
        setGameMode("normal");
        console.log("‚úÖ Urutan serangan zombie selesai");
      }
    }, 50);

    setTimeout(() => {
      clearInterval(attackInterval);
      setZombieState({
        isAttacking: false,
        targetPlayerId: null,
        attackProgress: 0,
        basePosition: 500,
        currentPosition: 500,
      });
      setGameMode("normal");
      setBackgroundFlash(false);
    }, 3000);
  }, []);

  // Handle correct answer
  const handleCorrectAnswer = useCallback((playerId: string, newSpeed: number) => {
    console.log(`‚úÖ Pemain ${playerId} menjawab benar! Kecepatan: ${newSpeed}`);
    setPlayerStates((prev) => ({
      ...prev,
      [playerId]: {
        ...prev[playerId],
        speed: newSpeed,
        lastAttackTime: Date.now(),
        countdown: undefined, // Reset countdown on correct answer
      },
    }));
  }, []);

  // Check for low speed and initiate countdown
  const checkLowSpeedPlayers = useCallback(() => {
    if (zombieState.isAttacking) return; // Don't start new countdowns during an attack

    Object.entries(playerStates).forEach(([playerId, state]) => {
      if (state.isBeingAttacked || state.health <= 0 || !players.find((p) => p.id === playerId)?.is_alive) return;

      if (state.speed <= 30 && state.countdown === undefined) {
        // Start countdown
        setPlayerStates((prev) => ({
          ...prev,
          [playerId]: {
            ...prev[playerId],
            countdown: 6, // Start at 6 seconds
          },
        }));

        const countdownInterval = setInterval(() => {
          setPlayerStates((prev) => {
            const currentState = prev[playerId];
            if (!currentState || currentState.countdown === undefined) {
              clearInterval(countdownInterval);
              return prev;
            }

            const newCountdown = currentState.countdown - 1;
            if (newCountdown <= 0 && currentState.speed <= 30) {
              // Trigger attack if countdown reaches 0 and speed still <= 30
              clearInterval(countdownInterval);
              const newHealth = Math.max(0, currentState.health - 1);
              const newSpeed = currentState.speed;

              // Update database
              supabase
                .from("player_health_states")
                .update({
                  health: newHealth,
                  speed: newSpeed,
                  is_being_attacked: true,
                  last_attack_time: new Date().toISOString(),
                })
                .eq("player_id", playerId)
                .then(() => {
                  handleZombieAttack(playerId, newHealth, newSpeed);
                });

              return {
                ...prev,
                [playerId]: {
                  ...currentState,
                  countdown: undefined,
                },
              };
            } else if (currentState.speed > 30) {
              // Cancel countdown if speed increases above 30
              clearInterval(countdownInterval);
              return {
                ...prev,
                [playerId]: {
                  ...currentState,
                  countdown: undefined,
                },
              };
            }

            return {
              ...prev,
              [playerId]: {
                ...currentState,
                countdown: newCountdown,
              },
            };
          });
        }, 1000);
      }
    });
  }, [playerStates, zombieState.isAttacking, handleZombieAttack, players]);

  // Fetch game room and players data
  const fetchGameData = useCallback(async () => {
    try {
      const { data: room, error: roomError } = await supabase
        .from("game_rooms")
        .select("*")
        .eq("room_code", roomCode.toUpperCase())
        .single();

      if (roomError) throw roomError;
      setGameRoom(room);

      const { data: playersData, error: playersError } = await supabase
        .from("players")
        .select("*")
        .eq("room_id", room.id)
        .order("joined_at", { ascending: true });

      if (playersError) throw playersError;
      setPlayers(playersData || []);

      const { data: healthData, error: healthError } = await supabase
        .from("player_health_states")
        .select("*")
        .eq("room_id", room.id);

      if (healthError) console.error("Gagal mengambil status kesehatan:", healthError);

      const { data: completionData, error: completionError } = await supabase
        .from("game_completions")
        .select("*, players(nickname, character_type)")
        .eq("room_id", room.id)
        .eq("completion_type", "completed");

      if (completionError) console.error("Gagal mengambil data penyelesaian:", completionError);
      else {
        const completed = completionData?.map((completion: any) => completion.players) || [];
        setCompletedPlayers(completed);
        if (completed.length > 0) {
          setShowCompletionPopup(true);
        }
      }

      if (playersData && playersData.length > 0) {
        initializePlayerStates(playersData, healthData || []);
      }
    } catch (error) {
      console.error("Gagal mengambil data permainan:", error);
    } finally {
      setIsLoading(false);
    }
  }, [roomCode, initializePlayerStates]);

  // Realtime subscriptions
  useEffect(() => {
    if (!gameRoom) return;

    console.log(`üîó Menyiapkan langganan real-time untuk ruangan ${gameRoom.id}`);
    const roomChannel = supabase
      .channel(`room-${gameRoom.id}-all`)
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "players", filter: `room_id=eq.${gameRoom.id}` },
        (payload) => {
          console.log("üë• Perubahan pemain terdeteksi:", payload);
          fetchGameData();
        }
      )
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "player_health_states", filter: `room_id=eq.${gameRoom.id}` },
        (payload) => {
          console.log("üíñ Perubahan status kesehatan terdeteksi:", payload);
          const healthState = payload.new as PlayerHealthState;
          if (healthState) {
            setPlayerHealthStates((prev) => ({
              ...prev,
              [healthState.player_id]: healthState,
            }));
            setPlayerStates((prev) => ({
              ...prev,
              [healthState.player_id]: {
                ...prev[healthState.player_id],
                health: healthState.health,
                speed: healthState.speed,
                isBeingAttacked: healthState.is_being_attacked,
                lastAttackTime: new Date(healthState.last_attack_time).getTime(),
                countdown: healthState.speed <= 30 && !healthState.is_being_attacked ? 6 : undefined,
              },
            }));

            if (healthState.is_being_attacked && !zombieState.isAttacking) {
              handleZombieAttack(healthState.player_id, healthState.health, healthState.speed);
            }
          }
        }
      )
      .on(
        "postgres_changes",
        { event: "INSERT", schema: "public", table: "player_answers", filter: `room_id=eq.${gameRoom.id}` },
        (payload) => {
          console.log("üìù Jawaban baru diterima:", payload);
          const answer = payload.new as any;
          const player = players.find((p) => p.id === answer.player_id);
          const playerName = player?.nickname || "Tidak Diketahui";
          if (answer.is_correct) {
            console.log(`‚úÖ ${playerName} menjawab benar! Kecepatan: ${answer.speed || 20}`);
            handleCorrectAnswer(answer.player_id, answer.speed || 20);
          } else {
            console.log(`‚ùå ${playerName} menjawab salah! Zombie akan menyerang jika kecepatan <= 30...`);
          }
        }
      )
      .on(
        "postgres_changes",
        { event: "INSERT", schema: "public", table: "game_completions", filter: `room_id=eq.${gameRoom.id}` },
        (payload) => {
          console.log("üèÜ Penyelesaian permainan terdeteksi:", payload);
          const completion = payload.new as GameCompletion;
          if (completion.completion_type === "completed") {
            const player = players.find((p) => p.id === completion.player_id);
            if (player) {
              setCompletedPlayers((prev) => {
                if (!prev.some((p) => p.id === player.id)) {
                  return [...prev, player];
                }
                return prev;
              });
              setShowCompletionPopup(true);
            }
          }
        }
      )
      .subscribe();

    return () => {
      console.log("üîå Membersihkan langganan real-time");
      supabase.removeChannel(roomChannel);
    };
  }, [gameRoom, handleZombieAttack, handleCorrectAnswer, fetchGameData, players, zombieState.isAttacking]);

  // Initial data fetch
  useEffect(() => {
    if (roomCode) {
      console.log(`üéÆ Menginisialisasi halaman host untuk ruangan: ${roomCode}`);
      fetchGameData();
    }
  }, [roomCode, fetchGameData]);

  // Check low speed players every second
  useEffect(() => {
    const interval = setInterval(() => {
      checkLowSpeedPlayers();
    }, 1000);

    return () => clearInterval(interval);
  }, [checkLowSpeedPlayers]);

  // Test image loading
  useEffect(() => {
    const testAllImages = async () => {
      const status: { [key: string]: boolean } = {};
      for (const character of characterGifs) {
        const primaryWorks = await testImageLoad(character.src);
        if (primaryWorks) {
          status[character.src] = true;
          continue;
        }
        const fallbackWorks = await testImageLoad(character.fallback);
        if (fallbackWorks) {
          status[character.fallback] = true;
          continue;
        }
        const rootFallbackWorks = await testImageLoad(character.rootFallback);
        status[character.rootFallback] = rootFallbackWorks;
      }
      const zombieWorks = await testImageLoad("/images/zombie.gif");
      status["/images/zombie.gif"] = zombieWorks;
      setImageLoadStatus(status);
    };
    testAllImages();
  }, []);

  const testImageLoad = (src: string): Promise<boolean> => {
    return new Promise((resolve) => {
      const img = new window.Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = src;
    });
  };

  // Handle client-side hydration and resize
  useEffect(() => {
    setIsClient(true);
    setScreenWidth(window.innerWidth);
    const handleResize = () => setScreenWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  // Animation timer
  useEffect(() => {
    const interval = setInterval(
      () => setAnimationTime((prev) => prev + 1),
      gameMode === "panic" ? 30 : 80
    );
    return () => clearInterval(interval);
  }, [gameMode]);

  // Helper for seamless looping
  const getLoopPosition = (speed: number, spacing: number, offset = 0) => {
    const totalDistance = screenWidth + spacing;
    const position = (animationTime * speed + offset) % totalDistance;
    return position > 0 ? position - spacing : totalDistance + position - spacing;
  };

  // Get working image path
  const getWorkingImagePath = (character: (typeof characterGifs)[0]) => {
    if (imageLoadStatus[character.src]) return character.src;
    if (imageLoadStatus[character.fallback]) return character.fallback;
    if (imageLoadStatus[character.rootFallback]) return character.rootFallback;
    return character.src;
  };

  if (!isClient || isLoading) {
    return (
      <div className="relative w-full h-screen bg-black flex items-center justify-center">
        <div className="text-white text-xl">Memuat Kejaran Zombie...</div>
      </div>
    );
  }

  const centerX = screenWidth / 2;

  return (
    <div
      className="relative w-full h-screen bg-black overflow-hidden"
      style={{
        transform: `translate(${Math.sin(animationTime * 0.1) * (gameMode === "panic" ? 5 : 2)}px, ${
          Math.cos(animationTime * 0.1) * (gameMode === "panic" ? 3 : 1)
        }px)`,
      }}
    >
      {/* Countdown Display */}
      <AnimatePresence>
        {Object.entries(playerStates).map(([playerId, state]) => {
          if (state.countdown !== undefined && state.countdown > 0) {
            const player = players.find((p) => p.id === playerId);
            if (!player) return null;
            return (
              <motion.div
                key={`countdown-${playerId}`}
                initial={{ opacity: 0, y: -50 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -50 }}
                className="absolute top-4 left-1/2 transform -translate-x-1/2 z-50"
              >
                <div className="bg-red-800/90 text-white font-mono text-lg px-4 py-2 rounded border border-red-500 shadow-lg animate-pulse">
                  {player.nickname} akan diserang dalam {state.countdown} detik! Tingkatkan kecepatan!
                </div>
              </motion.div>
            );
          }
          return null;
        })}
      </AnimatePresence>

      <GameBackground
        animationTime={animationTime}
        gameMode={gameMode}
        screenWidth={screenWidth}
        getLoopPosition={getLoopPosition}
      />
      <BackgroundEffects
        animationTime={animationTime}
        gameMode={gameMode}
        screenWidth={screenWidth}
        backgroundFlash={backgroundFlash}
        getLoopPosition={getLoopPosition}
      />
      <PlayersPanel
        players={players}
        gameRoom={gameRoom}
        roomCode={roomCode}
        playerStates={playerStates}
        playerHealthStates={playerHealthStates}
        zombieState={zombieState}
        recentAttacks={recentAttacks}
        getCharacterByType={getCharacterByType}
        getWorkingImagePath={getWorkingImagePath}
      />
      <RunningCharacters
        players={players}
        playerStates={playerStates}
        playerHealthStates={playerHealthStates}
        zombieState={zombieState}
        animationTime={animationTime}
        gameMode={gameMode}
        centerX={centerX}
        getCharacterByType={getCharacterByType}
        getWorkingImagePath={getWorkingImagePath}
      />
      <ZombieCharacter
        zombieState={zombieState}
        animationTime={animationTime}
        gameMode={gameMode}
        centerX={centerX}
      />
      <GameUI
        roomCode={roomCode}
        players={players}
        gameMode={gameMode}
        zombieState={zombieState}
        playerHealthStates={playerHealthStates}
      />
      {/* Completion Popup */}
      <AnimatePresence>
        {showCompletionPopup && completedPlayers.length > 0 && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 bg-black/80 flex items-center justify-center z-50"
            onClick={() => setShowCompletionPopup(false)}
          >
            <motion.div
              initial={{ scale: 0.8, y: 50 }}
              animate={{ scale: 1, y: 0 }}
              exit={{ scale: 0.8, y: 50 }}
              className="bg-gray-900/90 border border-red-900/50 rounded-lg p-8 max-w-md w-full text-center"
              onClick={(e) => e.stopPropagation()}
            >
              <h2 className="text-2xl font-bold text-white font-mono mb-4">
                Selamat Anda Lolos dari Kejaran!
              </h2>
              <div className="flex justify-center gap-4 mb-6">
                {completedPlayers.map((player) => {
                  const character = getCharacterByType(player.character_type);
                  return (
                    <img
                      key={player.id}
                      src={getWorkingImagePath(character)}
                      alt={character.alt}
                      className="w-16 h-16 object-contain"
                    />
                  );
                })}
              </div>
              <div className="text-white font-mono mb-6">
                <p className="text-lg mb-2">Pemain yang Lolos:</p>
                <ul className="list-disc list-inside">
                  {completedPlayers.map((player) => (
                    <li key={player.id}>{player.nickname}</li>
                  ))}
                </ul>
              </div>
              <button
                onClick={() => setShowCompletionPopup(false)}
                className="bg-red-600 hover:bg-red-500 text-white font-mono py-2 px-4 rounded"
              >
                Tutup
              </button>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}



dan ini adalah zombiecharacter.tsx
"use client";

import Image from "next/image";
import { useRef } from "react";

interface ZombieState {
  isAttacking: boolean;
  targetPlayerId: string | null;
  attackProgress: number;
  basePosition: number;
  currentPosition: number;
}

interface ZombieCharacterProps {
  zombieState: ZombieState;
  animationTime: number;
  gameMode: "normal" | "panic";
  centerX: number;
}

export default function ZombieCharacter({
  zombieState,
  animationTime,
  gameMode,
  centerX,
}: ZombieCharacterProps) {
  const attackRef = useRef<HTMLDivElement>(null);
  const ZOMBIE_SPEED = 30;

  const normalMovement = {
    x: Math.sin(animationTime * 0.4) * (gameMode === "panic" ? 140 : 30),
    y: Math.sin(animationTime * 1.0) * (gameMode === "panic" ? 50 : 15),
    rotation: Math.sin(animationTime * (gameMode === "panic" ? 0.3 : 0.15)) * (gameMode === "panic" ? 20 : 12),
    scale: gameMode === "panic" ? 2.0 : 1.8,
  };

  const attackMovement = {
    x: Math.sin(animationTime * 0.8) * 15,
    y: Math.sin(animationTime * 2.0) * 8,
    rotation: Math.sin(animationTime * 3) * 10,
    scale: 2.2,
  };

  const currentMovement = zombieState.isAttacking ? attackMovement : normalMovement;

  return (
    <div
      ref={attackRef}
      className="absolute z-40 origin-bottom"
      style={{
        left: `${centerX - zombieState.currentPosition + currentMovement.x}px`,
        top: "80%",
        transform: `translateY(${currentMovement.y}px)`,
        transition: zombieState.isAttacking ? "transform 0.05s linear" : "transform 0.1s ease-out",
      }}
    >
      <div className="relative">
        {/* Indikator serangan */}
        {zombieState.isAttacking && (
          <div className="absolute -top-10 left-1/2 transform -translate-x-1/2 px-3 py-1.5 rounded text-sm bg-red-800/90 text-white animate-pulse border border-red-500 shadow-lg">
            MENYERANG! üßü‚Äç‚ôÇÔ∏è
          </div>
        )}

        {/* Efek darah saat menyerang */}
        {zombieState.isAttacking && (
          <div className="absolute -top-6 left-1/2 transform -translate-x-1/2 w-2 h-8 bg-red-600 animate-drip">
            <div className="absolute bottom-0 w-4 h-4 bg-red-600 rounded-full animate-pulse"></div>
          </div>
        )}

        <Image
          src="/images/zombie.gif"
          alt="Zombie"
          width={140}
          height={140}
          className="drop-shadow-lg"
          unoptimized
          style={{
            imageRendering: "pixelated",
            filter: zombieState.isAttacking
              ? "brightness(1.4) contrast(1.6) saturate(1.4) drop-shadow(0 0 20px rgba(255,50,50,0.8))"
              : gameMode === "panic"
                ? "brightness(1.3) contrast(1.5) saturate(1.3) drop-shadow(0 0 10px rgba(255,50,50,0.5))"
                : "brightness(1.1) contrast(1.2)",
            transform: `scale(${currentMovement.scale}) rotate(${currentMovement.rotation}deg)`,
            transformOrigin: "bottom center",
            transition: "all 0.1s ease-out",
          }}
        />

        {/* Jejak zombie saat menyerang */}
        {zombieState.isAttacking &&
          [...Array(4)].map((_, i) => (
            <div key={`blood-trail-${i}`} className="absolute top-0 left-0">
              <Image
                src="/images/zombie.gif"
                alt="Zombie Trail"
                width={140}
                height={140}
                className="absolute"
                unoptimized
                style={{
                  imageRendering: "pixelated",
                  opacity: 0.35 - i * 0.1,
                  filter: "brightness(0.7) contrast(1.1) hue-rotate(10deg)",
                  transform: `translateX(${-15 - i * 10}px) scale(${0.95 - i * 0.1})`,
                  animation: `fadeOut 0.6s ${i * 0.15}s forwards`,
                }}
              />
            </div>
          ))}

        {/* Efek aura */}
        <div
          className={`absolute -inset-3 rounded-full blur-md ${
            zombieState.isAttacking
              ? "bg-red-600 opacity-25 animate-pulse-slow"
              : gameMode === "panic"
                ? "bg-red-500 opacity-15"
                : "bg-green-500 opacity-10"
          }`}
        />

        {/* Indikator kecepatan zombie */}
        <p
          className={`absolute -bottom-8 left-1/2 transform -translate-x-1/2 font-mono text-sm ${
            zombieState.isAttacking ? "text-red-400 animate-pulse" : "text-gray-400"
          }`}
        >
          Kecepatan: {ZOMBIE_SPEED}
        </p>
      </div>

      <style jsx>{`
        @keyframes drip {
          0% {
            height: 0;
            opacity: 1;
          }
          50% {
            height: 8px;
            opacity: 1;
          }
          100% {
            height: 16px;
            opacity: 0;
          }
        }
        .animate-drip {
          animation: drip 0.7s infinite;
        }

        @keyframes pulse {
          0%,
          100% {
            opacity: 0.9;
          }
          50% {
            opacity: 1;
          }
        }
        .animate-pulse {
          animation: pulse 0.6s infinite;
        }

        @keyframes pulse-slow {
          0%,
          100% {
            opacity: 0.2;
          }
          50% {
            opacity: 0.3;
          }
        }
        .animate-pulse-slow {
          animation: pulse-slow 1.8s infinite;
        }

        @keyframes fadeOut {
          0% {
            opacity: 0.35;
          }
          100% {
            opacity: 0;
          }
        }
      `}</style>
    </div>
  );
}

dan ini adalah runningcharacter.tsx
"use client";

import { Heart } from "lucide-react";
import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";

interface Player {
  id: string;
  nickname: string;
  character_type: string;
  score: number;
  is_alive: boolean;
  joined_at: string;
}

interface PlayerHealthState {
  id: string;
  player_id: string;
  room_id: string;
  health: number;
  max_health: number;
  speed: number; // Tambahkan speed
  is_being_attacked: boolean;
  last_attack_time: string;
}

interface PlayerState {
  id: string;
  health: number;
  speed: number; // Tambahkan speed
  isBeingAttacked: boolean;
  position: number;
  lastAttackTime: number;
  attackIntensity: number;
}

interface ZombieState {
  isAttacking: boolean;
  targetPlayerId: string | null;
  attackProgress: number;
  basePosition: number;
  currentPosition: number;
}

interface RunningCharactersProps {
  players: Player[];
  playerStates: { [playerId: string]: PlayerState };
  playerHealthStates: { [playerId: string]: PlayerHealthState };
  zombieState: ZombieState;
  animationTime: number;
  gameMode: "normal" | "panic";
  centerX: number;
  getCharacterByType: (type: string) => any;
  getWorkingImagePath: (character: any) => string;
}

export default function RunningCharacters({
  players,
  playerStates,
  playerHealthStates,
  zombieState,
  animationTime,
  gameMode,
  centerX,
  getCharacterByType,
  getWorkingImagePath,
}: RunningCharactersProps) {
  const [eliminatedPlayers, setEliminatedPlayers] = useState<Set<string>>(new Set());
  const router = useRouter();

  useEffect(() => {
    const newEliminated = new Set<string>();
    const allPlayersEliminated = players.every((player) => {
      const playerState = playerStates[player.id];
      const healthState = playerHealthStates[player.id];
      const health = playerState?.health ?? healthState?.health ?? 3;
      const isEliminated = !player.is_alive || health <= 0;
      if (isEliminated) {
        newEliminated.add(player.id);
      }
      return isEliminated;
    });

    setEliminatedPlayers(newEliminated);

    if (allPlayersEliminated && players.length > 0) {
      const redirectTimeout = setTimeout(() => {
        router.push("/");
      }, 1000);
      return () => clearTimeout(redirectTimeout);
    }
  }, [players, playerStates, playerHealthStates, router]);

  return (
    <div className="absolute bottom-20 z-30">
      {players.slice(0, 5).map((player, i) => {
        const character = getCharacterByType(player.character_type);
        const workingPath = getWorkingImagePath(character);
        const playerState = playerStates[player.id];
        const healthState = playerHealthStates[player.id];
        const isBeingAttacked = playerState?.isBeingAttacked || false;
        const health = playerState?.health ?? healthState?.health ?? 3;
        const speed = playerState?.speed ?? healthState?.speed ?? 20;
        const attackIntensity = playerState?.attackIntensity ?? 0;
        const isZombieTarget = zombieState.targetPlayerId === player.id;
        const isEliminated = !player.is_alive || health <= 0;

        if (isEliminated && !eliminatedPlayers.has(player.id)) {
          return null;
        }

        const speedOffset = (speed - 20) * 10; // Sesuaikan posisi berdasarkan kecepatan
        const charX =
          centerX -
          130 +
          i * 120 +
          speedOffset +
          Math.sin(animationTime * (gameMode === "panic" ? 1.2 : 0.4) + i) * (gameMode === "panic" ? 60 : 15);
        const charY =
          -30 +
          Math.abs(Math.sin(animationTime * (gameMode === "panic" ? 2 : 0.6) + i * 0.5)) *
          (gameMode === "panic" ? 25 : 8);

        const attackShakeIntensity = isBeingAttacked ? attackIntensity * 5 : 0;
        const attackShakeX = isBeingAttacked ? Math.sin(animationTime * 20) * attackShakeIntensity : 0;
        const attackShakeY = isBeingAttacked ? Math.sin(animationTime * 15) * attackShakeIntensity : 0;
        const attackScale = isBeingAttacked ? 1 + attackIntensity * 0.1 : 1;

        return (
          <div
            key={`character-${player.id}`}
            className={`absolute transition-all duration-500 ease-out ${
              isEliminated ? "opacity-0 scale-0" : "opacity-100 scale-100"
            }`}
            style={{
              left: `${charX}px`,
              bottom: `${charY}px`,
              zIndex: isEliminated ? 25 : isZombieTarget ? 40 : 35,
              transform: `translate(${attackShakeX}px, ${attackShakeY}px) scale(${attackScale})`,
              transition: isEliminated
                ? "opacity 0.5s ease-out, transform 0.5s ease-out"
                : "all 0.1s ease-out",
            }}
            onTransitionEnd={() => {
              if (isEliminated) {
                setEliminatedPlayers((prev) => {
                  const newSet = new Set(prev);
                  newSet.delete(player.id);
                  return newSet;
                });
              }
            }}
          >
            <div className="relative flex flex-col items-center">
              <div
                className={`drop-shadow-2xl transition-all duration-100 ${
                  isZombieTarget && !isEliminated ? "animate-bounce scale-110 z-50" : ""
                }`}
                style={{
                  width: gameMode === "panic" ? 120 : 96,
                  height: gameMode === "panic" ? 120 : 96,
                  backgroundImage: `url(${workingPath})`,
                  backgroundSize: "contain",
                  backgroundRepeat: "no-repeat",
                  backgroundPosition: "center",
                  imageRendering: "pixelated",
                  filter: isEliminated
                    ? "grayscale(100%) brightness(0.3) contrast(1.2)"
                    : isZombieTarget
                      ? "brightness(1.8) contrast(2) saturate(1.8) hue-rotate(15deg)"
                      : gameMode === "panic"
                        ? "brightness(1.2) contrast(1.4) saturate(1.2)"
                        : "brightness(1.1) contrast(1.2)",
                  transform: `scale(${gameMode === "panic" ? 1.8 : 1.6})`,
                }}
              />

              <div className="absolute -top-8 left-1/2 transform -translate-x-1/2 flex gap-1">
                {[...Array(3)].map((_, heartIndex) => (
                  <Heart
                    key={heartIndex}
                    className={`w-4 h-4 transition-all ${
                      heartIndex < health
                        ? isZombieTarget
                          ? "text-red-500 fill-red-500"
                          : "text-red-500 fill-red-500"
                        : "text-gray-600 fill-gray-600"
                    }`}
                  />
                ))}
              </div>

              <p className="text-white font-mono text-sm mt-1 text-center">{player.nickname}</p>
              <p className="text-gray-400 font-mono text-xs">Kecepatan: {speed}</p>

              {isEliminated && (
                <div className="absolute -top-14 left-1/2 transform -translate-x-1/2 px-2 py-1 bg-gray-800 text-gray-300 text-xs font-bold rounded">
                  TERELIMINASI
                </div>
              )}

              <div
                className="absolute -bottom-4 left-1/2 transform -translate-x-1/2 w-20 h-4 bg-black rounded-full opacity-30 blur-md"
                style={{
                  transform: `translateX(-50%) scaleX(${0.8 + Math.sin(animationTime * 0.6) * 0.2})`,
                }}
              />

              {isZombieTarget && !isEliminated && (
                <div className="absolute -inset-2 border-2 border-red-500 rounded-full animate-pulse" />
              )}
            </div>
          </div>
        );
      })}
    </div>
  );
}

